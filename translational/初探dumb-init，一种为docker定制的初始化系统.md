# [译]初探dumb-init，为docker容器定制的初始化系统

原文见[Introducing dumb-init, an init system for Docker containers](https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html)

Yelp大量使用了Docker容器：我们在容器中跑测试，以容器为基础构建工具，甚至用容器来部署生产环境。在这篇推文中，我将介绍在容器内部常用的dumb-init，一个用c语言写的简单初始化系统。

通常来说，即使运行的进程很简单，正常的初始化系统（如systemd或sysvinit）也是不可缺少的。但轻量级的容器颠覆了这种机制，让初始化系统的缺席成为了可能。然而，初始化系统的缺席往往也会导致错误的进程和信号处理，也会导致容器无法被优雅地停止、泄漏本该被摧毁的容器等问题。

dumb-init使用起来方便，也能解决以上问题。在执行其他容器命令前进行添加，dumb-init就会自动承担起pid=1进程的角色，将其它进程列为pid ～2，并代理它所接收到的所有信号。这有助于避免内核针对pid=1的进程执行的特殊行为，同时也承担起初始化系统的基本职责（如清理孤儿僵尸进程）。

## 动机：将Docker容器塑造为常规进程

我们真正想做的，其实是让Docker容器以普通进程的形式存在，从而我们能逐渐地把工具和基础设施迁移到Docker。与其强迫开发者放弃已存在的工作流，倒不如在开发者意识不到在调用Docker的情况下，将单独的命令移到容器中。

这种做法也让我们在开发中有了一种实际的方法来使用Docker。与其要求所有的进程都存在与容器中，倒不如选择性地使用容器。从商业或者技术角度来看，有价值，这种情况下我们才该使用容器。

要达到这一目标，我们希望在容器外部看，进程能表现地像不在容器内一样。这就意味着，我们需要处理用户输入、对信号有相同的响应、让进程在恰当的时刻死亡。尤其是向```docker run```发送信号的时候，我们希望容器内部的进程能接收到完全一样的信号。
在我们将Docker容器塑造成常规进程的过程中，除了Linux系统如何处理进程、会话和信号之外，我们发现了更多的奥妙。

## 容器内部的进程行为

容器的独特之处，就在于它的单进程模型。在传统的服务器上，即便是最小化方式的应用安装，至少也会运行一个复杂的初始化系统、cron（定时）、syslog（系统日志）和SSH daemon端。

单进程模式的容器很容器启动和使用资源，重点在于对于多数操作，那些容器可以视为Linux系统。在容器内部，pid=1进程作为初始化系统，需要遵守特殊的规则和职责。

那么，容器中pid=1进程到底是如何的呢？以下是两个常见的场景。

### 场景1:shell命令作pid=1进程
Dockerfile的妙用之一，就是如果在声明容器命令时，不使用推荐的JSON语法，Docker会在执行时将命令转换成shell命令。
这就导致进城树的结构如下：

 - docker run (主机)

 - - /bin/sh (PID 1, 容器内部)

 - - - python my_server.py (PID ~2, 容器内部)

让shell命令作pid=1进程，会使得向其它进程发送信号几乎不可能。发送到shell命令的信号不会被转发给子进程，另外，除非进程退出，shell命令是不会退出的。杀死容器的唯一方式，就是向容器发送SIGKILL命令（或者进程偶然死亡的情况）。
正是因为这个原因，shell命令作pid=1进程的情况应该尽可能避免。如果这种情况难以避免（举例来说，如果想要在容器内运行两个不相干的进程），应该```exec```最后一个进程来取代shell命令。

### 场景2: pid=1进程
当你在Dockerfile中使用推荐的语法时，进程会被立刻启动并作为容器内部的初始化进程，因此进程树会是这样的：

 - docker run (主机)

 - - python my_server.py (PID 1,容器内部)

这种场景会比第一种要好，你的进程能真实地接受到发送的信号。然而，作为pid为1的进程，在某些情况下它并不会如你所期待的方式执行.

## 向pid=1进程发信号的困难

linux内核将pid=1进程视为特殊例子，因此pid=1进程处理信号有一套特殊的规则。这套特殊规则经常会让程序或者工程师的期望破灭。
首先，我们来讲些背景知识。任何进程都会注册一些handler来处理TERM信号，并用这些handler执行进程退出前的清理工作。如果一个进程没有注册自身的信号handler，那么内核就会自动回落到TERM信号的默认响应行为：杀死进程。
然而对于pid=1进程，当内核向进程转发TERM信号时，内核并不会回落到任何默认行为。如果你的pid=1进程没有注册自身的handler（大多数进程都是这样），TERM信号将不会在进程上产生任何效果。
既然我们想把容器塑造成进程，我们会想要发送SIGTERM信号给```docker run```命令，从而达到停下容器的效果。不幸的是，这通常没法实现。
当```docker run```接收到SIGTERM信号时，它会把信号转发给容器，然后自己退出，即使容器本身并没有死亡。事实上，TERM信号经常无法停止进程，这是由pid=1进程的特殊性导致的。
即使使用```docker stop```命令不会执行你所期待的结果，stop命令会发送TERM（这个信号python不会注意），等待十秒，在进程还未停止时发送kill，立刻停止进程，完全没有执行清理工作的时间。
无法合理地向容器内部的服务发送信号，这会带来很多开发和生产方面的隐患。举例来说，当部署一个app的新版本时，可能会在未执行清理工作的情况下杀死了老版本（很大可能在响应一个请求的过程中死亡，或者留下对数据库的连接）。这也会导致CI系统（例如Jenkins）中的一些常见问题，废弃的测试退出了，而容器还在后台跑着。
其它的信号也会有这些问题。最常见的例子就是SIGINT，这个信号是你在终端按下^C时发出的。因为这个信号比SIGTERM更少见，想要手动杀死开发环境中的服务器更是麻烦重重。

## dumb-init来救场

为了解决这个需求，我们开发了dumb-init，一个供Linux容器内部使用的极简初始化系统。不再直接执行服务器进程，而是在Dockerfile文件里用dumb-init 做前缀，例如CMD ["dumb-init", "python", "my_server.py"]。这样会创建一个如下的进城树：

 - docker run (主机上)

 - - dumb-init (PID 1, 容器内部)

 - - - python my_server.py (PID ~2,容器内部)

dumb-init会为每一个可能被捕获到的信号注册一个对应的handler，并将这些信号转发到进程会话中。因为python进程不再是pid=1进程，当dumb-init转发TERM这类信号时，如果相关的handler没被注册，内核会执行默认行为（杀死进程）。
使用一个常规的初始化系统也能解决这个问题，但会增大复杂度和资源利用率。而dumb-init能用简单有效地解决这个问题。它会将真正的进程收作它的子进程，并把收到的信号转发给它们。除非真正的进程死亡了，dumb-init才会死亡，这为清理工作提供了时间。
dumb-init是以静态链接的二进制文件部署的，它没有额外的依赖。它是一个完美的简易初始化系统，能并添加到任意容器。我们建议在Docker容器内使用dumb-init，dumb-init不仅能优化信号处理，也能承担初始化系统的工作，例如收割孤儿僵尸进程。
